package LC901_1200;
import java.util.*;
public class LC924_MinimizeMalwareSpread {
    /**
     * You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is
     * directly connected to the jth node if graph[i][j] == 1.
     *
     * Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least
     * one of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware
     * will continue until no more nodes can be infected in this manner.
     *
     * Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of
     * malware stops. We will remove exactly one node from initial.
     *
     * Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize
     * M(initial), return such a node with the smallest index.
     *
     * Note that if a node was removed from the initial list of infected nodes, it might still be infected later due
     * to the malware spread.
     *
     * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
     * Output: 0
     *
     * Constraints:
     *
     * n == graph.length
     * n == graph[i].length
     * 2 <= n <= 300
     * graph[i][j] is 0 or 1.
     * graph[i][j] == graph[j][i]
     * graph[i][i] == 1
     * 1 <= initial.length <= n
     * 0 <= initial[i] <= n - 1
     * All the integers in initial are unique.
     * @param graph
     * @param initial
     * @return
     */
    // time = O(n^2), space = O(n)
    private int[] parent;
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        parent = new int[n];
        for (int i = 0; i < n; i++) parent[i] = i;
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && graph[i][j] == 1 && findParent(i) != findParent(j)) {
                    union(i, j);
                }
            }
        }

        // count number of nodes in each group
        HashMap<Integer, Integer> map = new HashMap<>(); // root idx -> all finally infected indices
        for (int i = 0; i < n; i++) {
            int p = findParent(i);
            map.put(p, map.getOrDefault(p, 0) + 1);
        }

        HashMap<Integer, List<Integer>> count = new HashMap<>(); // root idx -> all initial indices
        for (int j : initial) {
            int p = findParent(j);
            count.putIfAbsent(p, new ArrayList<>());
            count.get(p).add(j);
        }

        int size = 0, res = -1;
        for (int x : count.keySet()) {
            if (count.get(x).size() == 1) {
                if (size < map.get(x)) {
                    size = map.get(x);
                    res = count.get(x).get(0);
                } else if (size == map.get(x)) {
                    res = Math.min(res, count.get(x).get(0));
                }
            }
        }
        if (res == -1) {
            Arrays.sort(initial);
            return initial[0];
        }
        return res;
    }

    private int findParent(int x) {
        if (x != parent[x]) parent[x] = findParent(parent[x]);
        return parent[x];
    }

    private void union(int x, int y) {
        x = parent[x];
        y = parent[y];
        if (x < y) parent[y] = x;
        else parent[x] = y;
    }
}
/**
 * Union Find
 * 求连通图
 * 如果一个连通分量里面有两或两个以上的点是初始感染点，那么无论我们隔离哪一个，最终整个连通图还是会全部感染。这种连通图是我们不想要的。
 * 如果一个连通分量里面只有一个点是初始感染点，那么只要我们隔离了这个点，就能最终拯救整个连通图。
 * 显然，我们希望找到最大的这样的连通图，意味着我们可以拯救更多的点，也就是题意里面的minimize M(initial)。
 * 特别注意，如果所有的连通分量都包含>=2个初始感染点，根据要求我们仍要返回一个点作为最终结果（显然应该是initial里面的最小值）。
 * 这意味着尽管我们隔离了这样一个点，但也仅能拯救这一个点而已。
 */
