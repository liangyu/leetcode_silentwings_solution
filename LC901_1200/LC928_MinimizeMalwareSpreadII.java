package LC901_1200;
import java.util.*;
public class LC928_MinimizeMalwareSpreadII {
    /**
     * You are given a network of n nodes represented as an n x n adjacency matrix graph, where the ith node is directly
     * connected to the jth node if graph[i][j] == 1.
     *
     * Some nodes initial are initially infected by malware. Whenever two nodes are directly connected, and at least one
     * of those two nodes is infected by malware, both nodes will be infected by malware. This spread of malware will
     * continue until no more nodes can be infected in this manner.
     *
     * Suppose M(initial) is the final number of nodes infected with malware in the entire network after the spread of
     * malware stops.
     *
     * We will remove exactly one node from initial, completely removing it and any connections from this node to any
     * other node.
     *
     * Return the node that, if removed, would minimize M(initial). If multiple nodes could be removed to minimize
     * M(initial), return such a node with the smallest index.
     *
     * Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
     * Output: 0
     *
     * Constraints:
     *
     * n == graph.length
     * n == graph[i].length
     * 2 <= n <= 300
     * graph[i][j] is 0 or 1.
     * graph[i][j] == graph[j][i]
     * graph[i][i] == 1
     * 1 <= initial.length < n
     * 0 <= initial[i] <= n - 1
     * All the integers in initial are unique.
     * @param graph
     * @param initial
     * @return
     */
    // S1: BFS + List
    // time = O(n^2), space = O(n)
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        List<Integer>[] sources = new List[n];
        for (int i = 0; i < n; i++) sources[i] = new ArrayList<>(); // 注意：不能用Arrays.fill(sources, new ArrayList<>())!!!
        HashSet<Integer> initials = new HashSet<>();
        for (int x : initial) initials.add(x);

        List<Integer>[] nextNodes = new List[n];
        for (int i = 0; i < n; i++) nextNodes[i] = new ArrayList<>(); // Arrays.fill不能用来fill object ref!!!
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && graph[i][j] == 1) {
                    nextNodes[i].add(j);
                    nextNodes[j].add(i);
                }
            }
        }

        for (int start : initial) {
            Queue<int[]> queue = new LinkedList<>();
            queue.offer(new int[]{start, start});
            HashSet<Integer> visited = new HashSet<>();
            visited.add(start);

            while (!queue.isEmpty()) {
                int[] cur = queue.poll();
                int node = cur[0], source = cur[1];

                for (int next : nextNodes[node]) {
                    if (visited.contains(next)) continue;
                    if (initials.contains(next)) continue;
                    sources[next].add(source);
                    queue.offer(new int[]{next, source});
                    visited.add(next);
                }
            }
        }

        HashMap<Integer, Integer> count = new HashMap<>();
        for (List<Integer> x : sources) {
            if (x.size() == 1) {
                int s = x.get(0);
                count.put(s, count.getOrDefault(s, 0) + 1);
            }
        }

        int size = 0, res = -1;
        for (int x : count.keySet()) {
            if (count.get(x) > size) {
                res = x;
                size = count.get(x);
            } else if (count.get(x) == size && x < res) res = x;
        }

        if (res == -1) {
            Arrays.sort(initial);
            return initial[0];
        }
        return res;
    }

    // S1.2: BFS + HashMap
    // time = O(n^2), space = O(n)
    public int minMalwareSpread2(int[][] graph, int[] initial) {
        int n = graph.length;
        HashMap<Integer, List<Integer>> sources = new HashMap<>();
        HashSet<Integer> initials = new HashSet<>();
        for (int x : initial) initials.add(x);

        HashMap<Integer, List<Integer>> nextNodes = new HashMap<>();
        for (int i = 0; i < n; i++) {
            for (int j = 0; j < n; j++) {
                if (i != j && graph[i][j] == 1) {
                    nextNodes.putIfAbsent(i, new ArrayList<>());
                    nextNodes.putIfAbsent(j, new ArrayList<>());
                    nextNodes.get(i).add(j);
                    nextNodes.get(j).add(i);
                }
            }
        }

        for (int start : initial) {
            Queue<int[]> queue = new LinkedList<>();
            queue.offer(new int[]{start, start});
            HashSet<Integer> visited = new HashSet<>();
            visited.add(start);

            while (!queue.isEmpty()) {
                int[] cur = queue.poll();
                int node = cur[0], source = cur[1];

                for (int next : nextNodes.getOrDefault(node, new ArrayList<>())) {
                    if (visited.contains(next)) continue;
                    if (initials.contains(next)) continue;
                    sources.putIfAbsent(next, new ArrayList<>());
                    sources.get(next).add(source);
                    queue.offer(new int[]{next, source});
                    visited.add(next);
                }
            }
        }

        HashMap<Integer, Integer> count = new HashMap<>();
        for (int x : sources.keySet()) {
            if (sources.get(x).size() == 1) {
                int s = sources.get(x).get(0);
                count.put(s, count.getOrDefault(s, 0) + 1);
            }
        }

        int size = 0, res = -1;
        for (int x : count.keySet()) {
            if (count.get(x) > size) {
                res = x;
                size = count.get(x);
            } else if (count.get(x) == size && x < res) res = x;
        }

        if (res == -1) {
            Arrays.sort(initial);
            return initial[0];
        }
        return res;
    }
}
/**
 * 把一个感染源去掉，原来的通路可能就不通了
 * 6
 * |
 * 0
 * |
 * 1 - x - 3 - 4
 *         |
 *         5
 * 关系到会不会感染的，看它跟哪些感染源是直接相连的
 * 如果直接相连的有2个的话，这里只允许删除一个，那还是会感染
 * 如果直接相连只有一个的话，删了就不会被感染
 * 有可能拯救的点，都是那些直接感染源只有一个，就把这个感染源干掉
 * 否则的话，无论如何都会被感染
 * 所以，我们的目的就变成，看每个点有几个直接感染源，
 * 如果只有1个的话，说明这个感染源可以通过remove那个感染源得到拯救
 * a,b,c,d => A
 * e,f,g => B
 * 选择多的remove，比如A
 * 一样多的，选择字母序最小的
 * 这个题就转化成，对于任何一个点，它有几个邻接的感染源
 * 最naive的方法：每个都尝试一遍，做一次bfs
 */
